let results = {
    let mut hmap: HashMap<String, Value> = HashMap::new();
    for column in rows[0].columns() {
        let k = column.name().to_string();
        let v: String = column.type_().to_string();
        hmap.insert(k, serde_json::json!(v));
    }
    hmap
};


fn get_rows_type_into_arr_in_arr_json(rows: Vec<Row>) -> String {
    let results: Vec<Vec<(String, serde_json::Value)>> = rows
        .into_iter()
        .map(|row| {
            let mut row_values: Vec<(String, serde_json::Value)> = Vec::new();

            for column in row.columns() {
                let column_name = column.name().to_string();
                let column_value = match column.type_() {
                    &Type::BOOL => {
                        let v: bool = row.get(column_name.as_str());
                        serde_json::json!(v)
                    }
                    &Type::INT2 => {
                        let v: i16 = row.get(column_name.as_str());
                        serde_json::json!(v)
                    }
                    &Type::INT4 => {
                        let v: i32 = row.get(column_name.as_str());
                        serde_json::json!(v)
                    }
                    &Type::INT8 => {
                        let v: i64 = row.get(column_name.as_str());
                        serde_json::json!(v)
                    }
                    &Type::FLOAT4 => {
                        let v: f32 = row.get(column_name.as_str());
                        serde_json::json!(v)
                    }
                    &Type::FLOAT8 => {
                        let v: f64 = row.get(column_name.as_str());
                        serde_json::json!(v)
                    }
                    // &Type::DATE => {
                    //     // let v: i32 = row.get(column_name.as_str());
                    //     // serde_json::json!(v)
                    // }
                    _ => {
                        let value: Result<String, _> = row.try_get(column_name.as_str());
                        let v = match value {
                            Ok(v) => serde_json::json!(v),
                            Err(_) => serde_json::json!(""),
                        };
                        v
                    }
                };

                row_values.push((column_name, column_value));
            }

            row_values
        })
        .collect();

    serde_json::to_string(&results).unwrap()
}